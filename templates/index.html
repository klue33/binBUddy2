{% extends "base.html" %}
{% block content %}
<style>
    /* --- Styles for Core App UI --- */
    .hidden { display: none; }
    
    #upload-section { text-align: center; }
    #upload-form {
        border: 2px dashed #555;
        padding: 2rem;
        border-radius: 10px;
        margin-bottom: 2rem;
    }
    .button-container { margin-top: 2rem; display: flex; flex-direction: column; align-items: center; gap: 1.5rem; }
    .button-container p { margin: 0.25rem 0 0 0; color: #888; text-align: center; }
    .button-primary { background-color: var(--primary-color); color: white; width: 80%; padding: 1rem; }
    .button-secondary { background-color: transparent; border: 1px solid var(--primary-color); color: var(--primary-color); width: 80%; padding: 1rem; }

    #match-container { display: grid; gap: 1.5rem; margin-top: 2rem; }
    .match-card {
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1.5rem;
        background-color: var(--card-background-color);
        transition: all 0.2s ease-in-out;
    }
    .match-card.highlighted {
        border: 2px solid var(--primary-color);
        box-shadow: 0 0 15px rgba(0, 123, 255, 0.5);
        transform: scale(1.02);
    }
    .match-card h3, .match-card h4 { margin-top: 0; }
    .match-card h4 { color: var(--primary-color); text-align: center; }

    .comps-grid { display: grid; grid-template-columns: 1fr; gap: 1rem; margin-top: 1rem; }
    .attributes-list { list-style-type: none; padding-left: 0; font-size: 0.9rem; }
    .attributes-list li { background-color: var(--background-color); padding: 0.5rem; border-radius: 4px; margin-bottom: 0.5rem; }
</style>

<!-- SECTION 1: UPLOAD -->
<section id="upload-section">
    <h2>Step 1: Upload a Photo</h2>
    <form id="upload-form">
        <label for="file-input">Drag & Drop a Photo or Click to Upload</label>
        <input type="file" id="file-input" required>
    </form>

    <!-- The two action buttons, initially hidden -->
    <div id="action-buttons" class="button-container hidden">
        <p><strong>Now, choose your goal:</strong></p>
        <div>
            <button id="btn-identify-primary" class="button-primary">Identify Primary Item</button>
            <p><small>Finds the single, most prominent object.</small></p>
        </div>
        <div>
            <button id="btn-scan-all" class="button-secondary">Scan for All Items & Rank by Value</button>
            <p><small>Detects multiple objects and sorts by price.</small></p>
        </div>
    </div>
    
    <div id="loading-indicator" class="hidden">
        <p>ðŸ”Ž Analyzing image with Vertex AI...</p>
    </div>
</section>

<!-- SECTION 2: CONFIRMATION -->
<section id="confirmation-section" class="hidden">
    <!-- Content is dynamically generated by renderMatches() -->
    <div id="match-container"></div>
</section>

<!-- SECTION 3: LISTING (No changes from before) -->
<section id="listing-section" class="hidden">
    <h2>Step 3: Create Your Listing</h2>
    <form id="listing-form">
        <label for="listing-title">Listing Title</label>
        <input type="text" id="listing-title" readonly>
        <label for="listing-description">Description</label>
        <textarea id="listing-description" rows="5"></textarea>
        <label for="listing-price">Set Your Price ($)</label>
        <input type="number" id="listing-price" step="0.01">
        <button type="button" onclick="alert('Listing content is ready to be copied!')">Generate Copy & Paste Listing</button>
    </form>
</section>
  <div id="crop-modal" class="modal-container hidden">
        <div class="modal-content">
            <h3>Crop Your Image</h3>
            <p>Adjust the box to focus on the item you want to identify.</p>
            <div class="img-container">
                <img id="image-to-crop">
            </div>
            <button id="btn-crop-confirm">Crop & Confirm</button>
        </div>
    </div>

<style>
    /* Styles for the new Modal */
    .modal-container {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex; justify-content: center; align-items: center; z-index: 1000;
    }
    .modal-content {
        background-color: var(--background-color); padding: 2rem;
        border-radius: 10px; max-width: 90vw; max-height: 90vh;
    }
    .img-container {
        max-height: 60vh; margin: 1rem 0;
    }
    /* Cropper.js requires the img to be a block element */
    #image-to-crop { display: block; max-width: 100%; }
</style>
<script>
    // --- STATE & DOM REFERENCES ---
    let productMatches = [];
    let confirmedProduct = {};

    const uploadSection = document.getElementById('upload-section');
    const confirmationSection = document.getElementById('confirmation-section');
    const listingSection = document.getElementById('listing-section');
    const uploadForm = document.getElementById('upload-form');
    const loadingIndicator = document.getElementById('loading-indicator');
    const matchContainer = document.getElementById('match-container');
    const actionButtons = document.getElementById('action-buttons');
    const btnIdentifyPrimary = document.getElementById('btn-identify-primary');
    const btnScanAll = document.getElementById('btn-scan-all');
    const fileInput = document.getElementById('file-input');

    // --- EVENT LISTENERS ---

    // Show the action buttons when a file is selected.
    fileInput.addEventListener('change', () => {
        if (fileInput.files.length > 0) {
            actionButtons.classList.remove('hidden');
        } else {
            actionButtons.classList.add('hidden');
        }
    });

    // Add listeners for each button to trigger the analysis with the correct mode.
    btnIdentifyPrimary.addEventListener('click', () => handleImageAnalysis('single'));
    btnScanAll.addEventListener('click', () => handleImageAnalysis('multi'));

    // Listen for clicks within the results container to handle selection.
    matchContainer.addEventListener('click', (e) => {
        if (e.target && e.target.classList.contains('confirm-btn')) {
            const productId = e.target.dataset.productId;
            confirmedProduct = productMatches.find(p => p.id === productId);
            if (confirmedProduct) {
                populateListingForm();
                confirmationSection.classList.add('hidden');
                listingSection.classList.remove('hidden');
            }
        }
    });

    // --- CORE FUNCTIONS ---

    /**
     * Main function to handle sending the image to the backend for analysis.
     * @param {string} mode - The analysis mode ('single' or 'multi').
     */
    async function handleImageAnalysis(mode) {
        if (fileInput.files.length === 0) {
            alert("Please select a file to upload.");
            return;
        }

        const formData = new FormData();
        formData.append('file', fileInput.files[0]);
        formData.append('mode', mode); // Send the mode to the backend

        loadingIndicator.classList.remove('hidden');
        actionButtons.classList.add('hidden');
        uploadForm.classList.add('hidden');

        try {
            const response = await fetch('/api/identify-item', { method: 'POST', body: formData });
            const data = await response.json();
            if (data.error) throw new Error(data.error);
            
            productMatches = data.matches;
            renderMatches();

            uploadSection.classList.add('hidden');
            confirmationSection.classList.remove('hidden');
        } catch (error) {
            console.error(`Error during '${mode}' analysis:`, error);
            alert("Could not analyze the image. Please try again.");
            uploadSection.classList.remove('hidden');
            uploadForm.classList.remove('hidden');
            if (fileInput.files.length > 0) actionButtons.classList.remove('hidden');
        } finally {
            loadingIndicator.classList.add('hidden');
        }
    }

    /**
     * Renders the product match cards in the confirmation section,
     * adapting the display for single vs. multi-object results.
     */
    function renderMatches() {
        const isMultiMode = productMatches.length > 1;

        // Set the main title based on the mode.
        if (isMultiMode) {
            matchContainer.innerHTML = '<h3>Scan Results: ' + productMatches.length + ' Items Found (Ranked by Value)</h3>';
        } else if (productMatches.length === 1) {
            matchContainer.innerHTML = '<h3>Result for Primary Item</h3>';
        } else {
            matchContainer.innerHTML = '<h3>No confident matches found.</h3><p>Please try another photo or ensure the item is clear.</p>';
            return;
        }

        // Loop through the sorted results and create a card for each.
        productMatches.forEach((product, index) => {
            const isHighestValue = isMultiMode && index === 0;

            // Dynamically build the list of attributes.
            let attributesHtml = '<ul class="attributes-list">';
            let hasAttributes = false;
            if (product.attributes && typeof product.attributes === 'object') {
                for (const [key, value] of Object.entries(product.attributes)) {
                    if (value) {
                        attributesHtml += `<li><strong>${key}:</strong> ${value}</li>`;
                        hasAttributes = true;
                    }
                }
            }
            attributesHtml += '</ul>';
            if (!hasAttributes) attributesHtml = ''; // Don't show an empty list

            // Generate the final HTML for the product card.
            matchContainer.innerHTML += `
                <article class="match-card ${isHighestValue ? 'highlighted' : ''}">
                    ${isHighestValue ? '<h4>â˜… #1 Highest Value â˜…</h4>' : ''}
                    <h3>${isMultiMode ? `#${index + 1}: ` : ''}${product.name}</h3>
                    <p><em>Brand: ${product.brand || 'Unknown'}</em></p>
                    
                    <!-- Only show full details for the top item in multi-mode, or for any item in single mode -->
                    ${!isMultiMode || isHighestValue ? `<p>${product.description || ''}</p>${attributesHtml}` : ''}
                    
                    <div class="comps-grid">
                        <div><strong>Est. Value</strong><br>$${(product.comps.high || 0).toFixed(2)}</div>
                    </div>
                    <button class="confirm-btn" data-product-id="${product.id}">âœ… Select to Create Listing</button>
                </article>
            `;
        });
    }

    /**
     * Populates the final listing form with the selected product's data.
     */
    function populateListingForm() {
        document.getElementById('listing-title').value = `For Sale: ${confirmedProduct.name}`;
        document.getElementById('listing-description').value = confirmedProduct.description;
        document.getElementById('listing-price').value = (confirmedProduct.comps.retail * 0.65).toFixed(2);
    }
</script>
<script>
    // --- STATE & DOM REFERENCES ---
    let productMatches = [];
    let confirmedProduct = {};
    let cropper = null; // Variable to hold the Cropper instance

    // ... (all other DOM references like uploadSection, etc.)
    const cropModal = document.getElementById('crop-modal');
    const imageToCrop = document.getElementById('image-to-crop');
    const btnCropConfirm = document.getElementById('btn-crop-confirm');

    // --- EVENT LISTENERS ---

    // 1. Listen for a file selection to INITIATE the cropping process.
    fileInput.addEventListener('change', (e) => {
        const files = e.target.files;
        if (files && files.length > 0) {
            const reader = new FileReader();
            reader.onload = (event) => {
                // When the file is read, set it as the source for our image tag
                imageToCrop.src = event.target.result;
                // Show the modal
                cropModal.classList.remove('hidden');
                // Destroy any old cropper instance
                if (cropper) {
                    cropper.destroy();
                }
                // Initialize Cropper.js on the image
                cropper = new Cropper(imageToCrop, {
                    viewMode: 1, // Restrict the crop box to not exceed the size of the canvas.
                    background: false,
                    autoCropArea: 0.8,
                });
            };
            // Read the image file as a Data URL
            reader.readAsDataURL(files[0]);
        }
    });

    // 2. Listen for the "Crop & Confirm" button click.
    btnCropConfirm.addEventListener('click', () => {
        if (!cropper) return;

        // Get the cropped image data as a Blob
        cropper.getCroppedCanvas({
            width: 1024, // Resize for faster processing
            height: 1024,
            imageSmoothingQuality: 'high',
        }).toBlob((blob) => {
            // Hide the modal
            cropModal.classList.add('hidden');
            // Now that we have the cropped blob, show the action buttons
            actionButtons.classList.remove('hidden');

            // Store the blob to be used by the analysis functions
            // This replaces using fileInput.files[0]
            window.croppedImageBlob = blob;

        }, 'image/jpeg');
    });

    // 3. The analysis buttons now use the stored blob.
    btnIdentifyPrimary.addEventListener('click', () => handleImageAnalysis('single'));
    btnScanAll.addEventListener('click', () => handleImageAnalysis('multi'));

    // ... (matchContainer click listener remains the same)

    // --- CORE FUNCTIONS ---

    /**
     * Main function updated to use the globally stored croppedImageBlob.
     */
    async function handleImageAnalysis(mode) {
        if (!window.croppedImageBlob) {
            alert("An image has not been cropped yet. Please upload and crop an image first.");
            return;
        }

        const formData = new FormData();
        // Append the blob instead of the original file
        formData.append('file', window.croppedImageBlob, 'cropped.jpg');
        formData.append('mode', mode);

        loadingIndicator.classList.remove('hidden');
        actionButtons.classList.add('hidden');
        uploadForm.classList.add('hidden');

        try {
            const response = await fetch('/api/identify-item', { method: 'POST', body: formData });
            // ... (The rest of this function remains exactly the same as before)
            // ...
        } catch (error) {
            // ... (Error handling remains the same)
        } finally {
            // ... (Finally block remains the same)
        }
    }
    
    // ... (renderMatches and populateListingForm functions remain the same)
</script>

{% endblock %}
